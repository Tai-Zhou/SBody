/**
 * @file Utility.hpp
 * @author Tai Zhou
 * @brief
 * @version 0.1
 * @date 2022-07-25
 *
 * @copyright Copyright (c) 2022
 *
 * The MultiFunctionSolver::Hybrid functions are based on code from `gsl/multiroots/hybrid.c`.
 *
 * The MultiFunctionSolver::Dnewton functions are based on code from `gsl/multiroots/dnewton.c`.
 *
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 * ----------------------------------------------------------------------------------------------------
 *
 * The function PolySolveCubic is based on `cubic_roots` from `boost/math/tools/cubic_roots.hpp`.
 * The function PolySolveQuartic is based on `quartic_roots` from `boost/math/tools/quartic_roots.hpp`.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef SBODY_UTILITY_H
#define SBODY_UTILITY_H

#include <string>
#include <vector>

#include <boost/array.hpp>
#include <boost/math/special_functions/ellint_rc.hpp>
#include <boost/math/special_functions/ellint_rf.hpp>
#include <boost/math/special_functions/ellint_rj.hpp>
#include <boost/math/tools/precision.hpp>
#include <fmt/core.h>
#include <gsl/gsl_math.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_mode.h>
#include <gsl/gsl_multimin.h>
#include <gsl/gsl_multiroots.h>
#include <gsl/gsl_odeiv2.h>
#include <gsl/gsl_permutation.h>
#include <gsl/gsl_poly.h>
#include <gsl/gsl_roots.h>
#include <gsl/gsl_sf_ellint.h>
#include <gsl/gsl_vector.h>

namespace SBody {
	/// Global absolute accuracy.
	inline double absolute_accuracy = 1e-15;

	/// Global relative accuracy.
	inline double relative_accuracy = 1e-15;

	/// \f$\pi/3\f$.
	constexpr long double M_PI_3 = 1.047197551196597746154214461093167628l;

	/// \f$3\pi/4\f$.
	constexpr long double M_3PI_4 = 2.35619449019234492884698253745962716l;

	/// \f$2\pi\f$.
	constexpr long double M_2PI = 6.28318530717958647692528676655900576l;

	/// \f$\pi^2\f$.
	constexpr long double M_PI2 = 9.86960440108935861883449099987615111l;

	/// \f$\sqrt{27}\f$
	constexpr long double M_SQRT27 = 5.19615242270663188058233902451761710l;

	/// Epsilon, a small value. \f$\varepsilon\f$.
	constexpr long double EPSILON = 1e-10l;

	/// \f$\sin\varepsilon\f$.
	constexpr long double SIN_EPSILON = 1e-10l;

	/// \f$\cos\varepsilon\f$.
	constexpr long double COS_EPSILON = 0.999999999999999999995l;

	/// Area of a circle with radius of GSL_SQRT_DBL_EPSILON. \f$\pi\varepsilon^2\f$
	constexpr long double EPSILON_CIRCLE_AREA = M_PI * GSL_DBL_EPSILON;

	constexpr long double GSL_ROOT3_2_DBL_EPSILON = 3.666852862501036033408990023698041e-11l;

	/// Sample number.
	constexpr int SAMPLE_NUMBER = 100;

	/// The angle corresponding to the sample number.
	constexpr long double ANGLE_INTERVAL = M_2PI / SAMPLE_NUMBER;

	/// Area of the regular polygon with SAMPLE_NUMBER edges.
	constexpr long double EPSILON_POLYGON_AREA = 0.06279051952931337 / ANGLE_INTERVAL * EPSILON_CIRCLE_AREA;

	enum Axis { X,
				Y,
				Z };

	enum Status {
		SUCCESS = 0,
		FAILURE = 1,
	};

	class Solver {
	  public:
		virtual int Iterate() = 0;
		virtual long double Root() = 0;
	};

	/**
	 * @brief
	 *
	 */
	class FunctionSolver : public Solver {
	  private:
		gsl_root_fsolver *solver_;

	  public:
		FunctionSolver(const gsl_root_fsolver_type *type = gsl_root_fsolver_brent) {
			solver_ = gsl_root_fsolver_alloc(type);
		}
		~FunctionSolver() {
			gsl_root_fsolver_free(solver_);
		}
		int Set(gsl_function *function, long double lower, long double upper) {
			return gsl_root_fsolver_set(solver_, function, lower, upper);
		}
		int Iterate() override {
			return gsl_root_fsolver_iterate(solver_);
		}
		int Solve() {
			while (gsl_root_test_interval(gsl_root_fsolver_x_lower(solver_), gsl_root_fsolver_x_upper(solver_), absolute_accuracy, relative_accuracy) != Status::SUCCESS)
				if (int status = gsl_root_fsolver_iterate(solver_); status != Status::SUCCESS)
					return status;
			return Status::SUCCESS;
		}
		long double Root() override {
			return gsl_root_fsolver_root(solver_);
		}
		long double Lower() {
			return gsl_root_fsolver_x_lower(solver_);
		}
		long double Upper() {
			return gsl_root_fsolver_x_upper(solver_);
		}
	};

	class DerivativeSolver : public Solver {
	  private:
		gsl_root_fdfsolver *solver_;

	  public:
		DerivativeSolver(const gsl_root_fdfsolver_type *type = gsl_root_fdfsolver_steffenson);
		DerivativeSolver(gsl_function_fdf *function, long double root, const gsl_root_fdfsolver_type *type = gsl_root_fdfsolver_steffenson);
		~DerivativeSolver();
		int Set(gsl_function_fdf *function, long double root);
		int Iterate() override;
		int Solve(long double epsabs, int max_iteration = 256);
		long double Root() override;
	};

	class MultiSolver {
	  public:
		virtual int Iterate() = 0;
		virtual int Solve(long double epsabs, int max_iteration) = 0;
		virtual int Solve(long double epsabs, long double epsrel, int max_iteration) = 0;
		virtual gsl_vector *Root() = 0;
		virtual gsl_vector *Value() = 0;
		virtual gsl_vector *StepSize() = 0;
	};

	struct HybridState {
		gsl_vector *x_trial;
		gsl_vector *f_trial;
		gsl_matrix *jacobian;
		gsl_matrix *lu;
		gsl_permutation *permutation;
		gsl_vector *newton;
		gsl_vector *gradient;
		long double trust_radius;
		long double epsilon_coefficient;
		bool directional;
	};

	struct HybridAdditionState {
		gsl_vector *x_trial;
		gsl_vector *x_trial2;
		gsl_vector *f_trial;
		gsl_vector *f_trial2;
		gsl_matrix *jacobian;
		gsl_matrix *lu;
		gsl_permutation *permutation;
		gsl_vector *newton;
		gsl_vector *gradient;
		long double trust_radius;
		long double epsilon_coefficient;
		long double gradient_coefficient;
		bool directional;
	};

	struct DNewtonState {
		gsl_vector *x_trial;
		gsl_vector *f_trial;
		gsl_matrix *jacobian;
		gsl_matrix *lu;
		gsl_permutation *permutation;
		long double trust_radius;
		long double epsilon_coefficient;
		bool directional;
	};
	struct DNewtonRotationTranslationState {
		gsl_vector *x_trial;
		gsl_vector *dx_translation;
		gsl_vector *f_trial;
		gsl_matrix *jacobian;
		gsl_matrix *lu;
		gsl_permutation *permutation;
		long double theta_obs;
		long double sin_theta_obs;
		long double cos_theta_obs;
		long double r_obj;
		long double sin_theta_obj;
		long double cos_theta_obj;
		long double phi_obj;
		long double projected_x;
		long double projected_y;
		long double iota_obj;
		long double trust_radius;
		long double epsilon_coefficient;
		bool directional;
		bool trace_to_plane;
	};
	struct D2NewtonState {
		gsl_vector *x_trial;
		gsl_vector *f_trial;
		gsl_vector *jacobian;
		gsl_matrix *hessian;
		gsl_matrix *lu;
		gsl_permutation *permutation;
		long double trust_radius;
	};
	struct ConjugateGradientState {
		long double iteration_coefficient;
		gsl_vector *x_trial;
		gsl_vector *f_trial;
		gsl_vector *last_dx;
		long double gradient_norm;
		gsl_matrix *jacobian;
		gsl_matrix *lu;
		gsl_permutation *permutation;
		long double trust_radius;
	};
	struct TriangleState {
		gsl_vector *x_trial;
		gsl_vector *f_trial;
		gsl_vector *x_a;
		gsl_vector *x_b;
		gsl_vector *f_a;
		gsl_vector *f_b;
	};
	struct DirectionState {
		int directional_num;
		long double trust_radius;
		long double delta_angle;
		long double central_angle;
		gsl_vector *x_trial, *x_rec;
		gsl_vector *f_trial, *f_rec;
	};

	extern const gsl_multiroot_fsolver_type *gsl_multiroot_fsolver_sbody_hybrid;
	extern const gsl_multiroot_fsolver_type *gsl_multiroot_fsolver_sbody_hybrid_addition;
	extern const gsl_multiroot_fsolver_type *gsl_multiroot_fsolver_sbody_dnewton;
	extern const gsl_multiroot_fsolver_type *gsl_multiroot_fsolver_sbody_dnewton_rotation;
	extern const gsl_multiroot_fsolver_type *gsl_multiroot_fsolver_sbody_dnewton_translation;
	extern const gsl_multiroot_fsolver_type *gsl_multiroot_fsolver_sbody_d2newton;
	extern const gsl_multiroot_fsolver_type *gsl_multiroot_fsolver_sbody_gradient;
	extern const gsl_multiroot_fsolver_type *gsl_multiroot_fsolver_sbody_conjugate;
	extern const gsl_multiroot_fsolver_type *gsl_multiroot_fsolver_sbody_triangle;
	extern const gsl_multiroot_fsolver_type *gsl_multiroot_fsolver_sbody_direction;

	class MultiFunctionSolver : public MultiSolver {
	  private:
		gsl_multiroot_fsolver *solver_;
		static int ScaleX(gsl_multiroot_function *function, gsl_vector *x, gsl_vector *f);
		static int OneSidedJacobian(gsl_multiroot_function *F, const gsl_vector *x, const gsl_vector *f, long double epsrel, gsl_matrix *jacobian);
		static int TwoSidedJacobian(gsl_multiroot_function *F, const gsl_vector *x, const gsl_vector *f, long double epsrel, gsl_matrix *jacobian);
		static int OneSidedDirectionalJacobian(gsl_multiroot_function *F, const gsl_vector *x, const gsl_vector *direction, const gsl_vector *f, long double epsrel, gsl_matrix *jacobian);
		static int TwoSidedDirectionalJacobian(gsl_multiroot_function *F, const gsl_vector *x, const gsl_vector *direction, const gsl_vector *f, long double epsrel, gsl_matrix *jacobian);
		static int Hessian(gsl_multiroot_function *F, const gsl_vector *x, const gsl_vector *f, long double epsrel, gsl_vector *jacobian, gsl_matrix *hessian);
		static void ComputeDiag(const gsl_matrix *J, gsl_vector *diag);
		static void UpdateDiag(const gsl_matrix *J, gsl_vector *diag);
		static long double ScaledEnorm(const gsl_vector *d, const gsl_vector *f);
		static int Dogleg(const gsl_matrix *r, const gsl_vector *qtf, const gsl_vector *diag, long double delta, gsl_vector *newton, gsl_vector *gradient, gsl_vector *p);
		static int Dogleg(long double trust_radius, long double newton_norm, long double newton_norm2, long double gradient_norm, long double gradient_norm2, long double newton_gradient_dot, const gsl_vector *newton, const gsl_vector *gradient, gsl_vector *dx);

	  public:
		MultiFunctionSolver(size_t n, const gsl_multiroot_fsolver_type *type = gsl_multiroot_fsolver_dnewton);
		~MultiFunctionSolver();
		int Set(gsl_multiroot_function *function, const gsl_vector *x);
		int Set(gsl_multiroot_function *function, const gsl_vector *x, long double theta_obs, long double sin_theta_obs, long double cos_theta_obs, long double r_obj, long double sin_theta_obj, long double cos_theta_obj, long double phi_obj, long double sin_phi_obj, long double cos_phi_obj, bool trace_to_plane);
		int Iterate() override;
		int Solve(long double epsabs, int max_iteration = 256) override;
		int Solve(long double epsabs, long double epsrel, int max_iteration = 256) override;
		gsl_vector *Root() override;
		gsl_vector *Value() override;
		gsl_vector *StepSize() override;
		static int HybridAlloc(void *vstate, size_t n);
		static int HybridSet(void *vstate, gsl_multiroot_function *function, gsl_vector *x, gsl_vector *f, gsl_vector *dx);
		static int HybridIterate(void *vstate, gsl_multiroot_function *function, gsl_vector *x, gsl_vector *f, gsl_vector *dx);
		static void HybridFree(void *vstate);
		static int HybridAdditionAlloc(void *vstate, size_t n);
		static int HybridAdditionSet(void *vstate, gsl_multiroot_function *function, gsl_vector *x, gsl_vector *f, gsl_vector *dx);
		static int HybridAdditionIterate(void *vstate, gsl_multiroot_function *function, gsl_vector *x, gsl_vector *f, gsl_vector *dx);
		static void HybridAdditionFree(void *vstate);
		static int DNewtonAlloc(void *vstate, size_t n);
		static int DNewtonSet(void *vstate, gsl_multiroot_function *function, gsl_vector *x, gsl_vector *f, gsl_vector *dx);
		static int DNewtonIterate(void *vstate, gsl_multiroot_function *function, gsl_vector *x, gsl_vector *f, gsl_vector *dx);
		static void DNewtonFree(void *vstate);
		static int DNewtonRotationTranslationAlloc(void *vstate, size_t n);
		static int DNewtonRotationTranslationSet(void *vstate, gsl_multiroot_function *function, gsl_vector *x, gsl_vector *f, gsl_vector *dx);
		static int DNewtonRotationIterate(void *vstate, gsl_multiroot_function *function, gsl_vector *x, gsl_vector *f, gsl_vector *dx);
		static int DNewtonTranslationIterate(void *vstate, gsl_multiroot_function *function, gsl_vector *x, gsl_vector *f, gsl_vector *dx);
		static void DNewtonRotationTranslationFree(void *vstate);
		static int D2NewtonAlloc(void *vstate, size_t n);
		static int D2NewtonSet(void *vstate, gsl_multiroot_function *function, gsl_vector *x, gsl_vector *f, gsl_vector *dx);
		static int D2NewtonIterate(void *vstate, gsl_multiroot_function *function, gsl_vector *x, gsl_vector *f, gsl_vector *dx);
		static void D2NewtonFree(void *vstate);
		static int GradientIterate(void *vstate, gsl_multiroot_function *function, gsl_vector *x, gsl_vector *f, gsl_vector *dx);
		static int ConjugateGradientAlloc(void *vstate, size_t n);
		static int ConjugateGradientSet(void *vstate, gsl_multiroot_function *function, gsl_vector *x, gsl_vector *f, gsl_vector *dx);
		static int ConjugateGradientIterate(void *vstate, gsl_multiroot_function *function, gsl_vector *x, gsl_vector *f, gsl_vector *dx);
		static void ConjugateGradientFree(void *vstate);
		static int TriangleAlloc(void *vstate, size_t n);
		static int TriangleSet(void *vstate, gsl_multiroot_function *function, gsl_vector *x, gsl_vector *f, gsl_vector *dx);
		static int TriangleRotationIterate(void *vstate, gsl_multiroot_function *function, gsl_vector *x, gsl_vector *f, gsl_vector *dx);
		static int TriangleLongestIterate(void *vstate, gsl_multiroot_function *function, gsl_vector *x, gsl_vector *f, gsl_vector *dx);
		static void TriangleFree(void *vstate);
		static int DirectionAlloc(void *vstate, size_t n);
		static int DirectionSet(void *vstate, gsl_multiroot_function *function, gsl_vector *x, gsl_vector *f, gsl_vector *dx);
		static int DirectionIterate(void *vstate, gsl_multiroot_function *function, gsl_vector *x, gsl_vector *f, gsl_vector *dx);
		static void DirectionFree(void *vstate);
	};

	class MultiDerivativeSolver : public MultiSolver {
	  private:
		gsl_multiroot_fdfsolver *solver_;

	  public:
		MultiDerivativeSolver(size_t n, const gsl_multiroot_fdfsolver_type *type = gsl_multiroot_fdfsolver_gnewton);
		MultiDerivativeSolver(gsl_multiroot_function_fdf *function, const gsl_vector *x, size_t n, const gsl_multiroot_fdfsolver_type *type = gsl_multiroot_fdfsolver_gnewton);
		~MultiDerivativeSolver();
		int Set(gsl_multiroot_function_fdf *function, const gsl_vector *x);
		int Iterate() override;
		int Solve(long double epsabs, long double epsrel, int max_iteration = 128) override;
		gsl_vector *Root() override;
		gsl_vector *Value() override;
		gsl_vector *StepSize() override;
	};

	class MultiMinimizer {
	  public:
		virtual int Iterate() = 0;
		virtual int Solve(long double epsabs) = 0;
		virtual gsl_vector *Root() = 0;
		virtual long double Value() = 0;
	};

	class MultiFunctionMinimizer : public MultiMinimizer {
	  private:
		gsl_multimin_fminimizer *solver_;

	  public:
		MultiFunctionMinimizer(size_t n, const gsl_multimin_fminimizer_type *type = gsl_multimin_fminimizer_nmsimplex2rand);
		~MultiFunctionMinimizer();
		int Set(gsl_multimin_function *function, const gsl_vector *x, const gsl_vector *step_size);
		int Iterate() override;
		int Solve(long double epsabs) override;
		gsl_vector *Root() override;
		long double Value() override;
		long double StepSize();
	};
	/**
	 * @brief A wrapper of the `gsl_vector`, `gsl_matrix`, and `gsl_permutation`.
	 *
	 */
	class GslBlock {
	  private:
		std::vector<gsl_vector *> vectors_;
		std::vector<gsl_matrix *> matrices_;
		std::vector<gsl_permutation *> permutations_;

	  public:
		/// Destructor
		~GslBlock();

		/**
		 * @brief `gsl_vector_alloc`, creates a vector of length `n`
		 *
		 * @param n length of the vector
		 * @return pointer
		 */
		gsl_vector *VectorAlloc(size_t n);

		/**
		 * @brief `gsl_vector_calloc`, creates a vector of length `n` and initializes all the elements of the vector to zero.
		 *
		 * @param n length of the vector
		 * @return pointer
		 */
		gsl_vector *VectorCalloc(size_t n);

		/**
		 * @brief `gsl_vector_alloc_from_block`, creates a vector as a slice of an existing `block`.
		 *
		 * @param block target block
		 * @param offset offset to the data block
		 * @param n length of the vector
		 * @param stride step-size of the vector
		 * @return pointer
		 */
		gsl_vector *VectorAllocFromBlock(gsl_block *block, const size_t offset, const size_t n, const size_t stride = 1);

		/**
		 * @brief `gsl_vector_alloc_row_from_matrix`, allocates a new `gsl_vector` which points to the `i`-th row of the `matrix`.
		 *
		 * @param matrix target matrix
		 * @param i row index
		 * @return pointer
		 */
		gsl_vector *VectorAllocRowFromMatrix(gsl_matrix *matrix, const size_t i);

		/**
		 * @brief `gsl_vector_alloc_col_from_matrix`, allocates a new `gsl_vector` which points to the `j`-th column of the `matrix`.
		 *
		 * @param matrix target matrix
		 * @param j column index
		 * @return pointer
		 */
		gsl_vector *VectorAllocColFromMatrix(gsl_matrix *matrix, const size_t j);

		/**
		 * @brief `gsl_matrix_alloc`, creates a matrix of size `n1` rows by `n2` columns.
		 *
		 * @param n1 rows of the matrix
		 * @param n2 columns of the matrix
		 * @return pointer
		 */
		gsl_matrix *MatrixAlloc(size_t n1, size_t n2);

		/**
		 * @brief `gsl_matrix_alloc`, creates a matrix of size `n1` rows by `n2` columns and initializes all the elements of the matrix to zero
		 *
		 * @param n1 rows of the matrix
		 * @param n2 columns of the matrix
		 * @return pointer
		 */
		gsl_matrix *MatrixCalloc(size_t n1, size_t n2);

		/**
		 * @brief `gsl_permutation_alloc`, allocates memory for a new permutation of size `n`
		 *
		 * @param n size of the permutation
		 * @return pointer
		 */
		gsl_permutation *PermutationAlloc(size_t n);

		/**
		 * @brief `gsl_permutation_alloc`, allocates memory for a new permutation of size `n` and initializes it to the identity
		 *
		 * @param n size of the permutation
		 * @return pointer
		 */
		gsl_permutation *PermutationCalloc(size_t n);
	};

	int CoordinateOrthogonalization(const gsl_vector *x, gsl_matrix *coordinate);

	template <typename Type>
	Type Power2(Type x) {
		return x * x;
	}

	template <typename Type>
	Type Power3(Type x) {
		return x * x * x;
	}

	template <typename Type>
	Type Power4(Type x) {
		x *= x;
		return x * x;
	}

	/**
	 * @brief Square root of `x`. Return `0` if `x` is negative.
	 *
	 * @param x number
	 * @return result
	 */
	template <typename Type>
	Type SquareRoot(Type x) {
		if (x <= 0.)
			return 0.;
		return sqrt(x);
	}

	/**
	 * @brief Square of `x` with the sign of `x`.
	 *
	 * @param x number
	 * @return result
	 */
	template <typename Type>
	Type SignSquare(Type x) {
		if (x < 0.)
			return -x * x;
		return x * x;
	}

	/**
	 * @brief Square root of `abs(x)` with the sign of `x`.
	 *
	 * @param x number
	 * @return result
	 */
	template <typename Type>
	Type SignSquareRoot(Type x) {
		if (x < 0.)
			return -sqrt(-x);
		return sqrt(x);
	}

	/**
	 * @brief Dot product of vector `x` and `y`. \f$\vec{x}\cdot\vec{y}\f$
	 *
	 * @param x vector
	 * @param y vector
	 * @param dimension dimension of the vector
	 * @return result
	 */
	template <typename Type>
	Type Dot(const Type x[], const Type y[], size_t dimension = 3) {
		if (dimension == 3)
			return x[0] * y[0] + x[1] * y[1] + x[2] * y[2];
		Type sum = 0.;
		while (dimension-- > 0)
			sum += x[dimension] * y[dimension];
		return sum;
	}

	/**
	 * @brief Dot product of vector `x`. \f$\vec{x}\cdot\vec{x}\f$
	 *
	 * @param x vector
	 * @param dimension dimension of the vector
	 * @return result
	 */
	template <typename Type>
	Type Dot(const Type x[], size_t dimension = 3) {
		if (dimension == 3)
			return x[0] * x[0] + x[1] * x[1] + x[2] * x[2];
		Type sum = 0.l;
		while (dimension-- > 0)
			sum += x[dimension] * x[dimension];
		return sum;
	}

	/**
	 * @brief Euclidean norm of `x`. \f$\|\vec{x}\|_2\f$.
	 *
	 * @param x vector
	 * @param dimension dimension of the vector
	 * @return result
	 */
	template <typename Type>
	Type Norm(const Type x[], size_t dimension = 3) {
		if (dimension == 3)
			return sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);
		Type sum = 0.;
		while (dimension-- > 0)
			sum += x[dimension] * x[dimension];
		return sqrt(sum);
	}
	template <typename Type, std::size_t N>
	Type Norm(const std::array<Type, N> &x) {
		if (N == 3)
			return sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);
		Type sum = 0.;
		for (int i = 0; i < N; ++i)
			sum += x[i] * x[i];
		return sqrt(sum);
	}

	/**
	 * @brief Cross product of vector `x` and `y`, stored in `z`. \f$\vec{z}=\vec{x}\times\vec{y}\f$.
	 *
	 * @param x 3 dimensional vector
	 * @param y 3 dimensional vector
	 * @param z 3 dimensional vector
	 * @return status
	 */
	template <typename Type>
	int Cross(const Type x[], const Type y[], Type z[]) {
		z[0] = x[1] * y[2] - x[2] * y[1];
		z[1] = x[2] * y[0] - x[0] * y[2];
		z[2] = x[0] * y[1] - x[1] * y[0];
		return Status::SUCCESS;
	}

	/**
	 * @brief Dot product of vector `x` and the cross product of vector `y` and vector `z`. \f$\vec{x}\cdot(\vec{y}\times\vec{z})\f$.
	 *
	 * @param x 3 dimensional vector
	 * @param y 3 dimensional vector
	 * @param z 3 dimensional vector
	 * @return result
	 */
	template <typename Type>
	Type DotCross(const Type x[], const Type y[], const Type z[]) {
		return x[0] * (y[1] * z[2] - y[2] * z[1]) + x[1] * (y[2] * z[0] - y[0] * z[2]) + x[2] * (y[0] * z[1] - y[1] * z[0]);
	}

	/**
	 * @brief Calculate the area of a triangle
	 *
	 * @param a side length
	 * @param b side length
	 * @param c side length
	 * @return result
	 */
	template <typename Type>
	Type TriangleArea(const std::array<Type, 3> &x, const std::array<Type, 3> &y, const std::array<Type, 3> &z) {
		const Type a = sqrt(Power2(y[0] - x[0]) + Power2(y[1] - x[1]) + Power2(y[2] - x[2])),
				   b = sqrt(Power2(z[0] - y[0]) + Power2(z[1] - y[1]) + Power2(z[2] - y[2])),
				   c = sqrt(Power2(x[0] - z[0]) + Power2(x[1] - z[1]) + Power2(x[2] - z[2])),
				   s = 0.5 * (a + b + c);
		return sqrt(s * (s - a) * (s - b) * (s - c));
	}

	// /**
	//  * @brief Calculate the area of a triangle
	//  *
	//  * @param a side length
	//  * @param b side length
	//  * @param c side length
	//  * @return result
	//  */
	// template <typename Type>
	// Type TriangleArea(Type a, Type b, Type c) {
	// 	const Type s = 0.5 * (a + b + c);
	// 	return sqrt(s * (s - a) * (s - b) * (s - c));
	// }

	/**
	 * @brief Calculate whether point \f$(x, y)\f$ locates inside the triangle \f$\Delta abc\f$.
	 *
	 * @param xa x coordiante of the vertex a
	 * @param ya y coordiante of the vertex a
	 * @param xb x coordiante of the vertex b
	 * @param yb y coordiante of the vertex b
	 * @param xc x coordiante of the vertex c
	 * @param yc y coordiante of the vertex c
	 * @param x x coordiante of the point
	 * @param y y coordiante of the point
	 * @return result
	 */
	template <typename Type>
	bool PointInTriangle(Type xa, Type ya, Type xb, Type yb, Type xc, Type yc, Type x = 0.0, Type y = 0.0) {
		const Type ap_cross_ab = (x - xa) * (yb - ya) - (y - ya) * (xb - xa);
		const Type bp_cross_bc = (x - xb) * (yc - yb) - (y - yb) * (xc - xb);
		const Type cp_cross_ca = (x - xc) * (ya - yc) - (y - yc) * (xa - xc);
		return (ap_cross_ab >= 0. && bp_cross_bc >= 0. && cp_cross_ca >= 0.) || (ap_cross_ab <= 0. && bp_cross_bc <= 0. && cp_cross_ca <= 0.);
	}

	template <typename Type>
	bool PointInTriangle(const std::array<Type, 2> &a, const std::array<Type, 2> &b, const std::array<Type, 2> &c) {
		return PointInTriangle(a[0], a[1], b[0], b[1], c[0], c[1]);
	}

	/**
	 * @brief Calculate whether point \f$p\f$ locates inside the triangle \f$\Delta abc\f$.
	 *
	 * @param a vertex a
	 * @param b vertex b
	 * @param c vertex c
	 * @param p point p
	 * @return result
	 */
	template <typename Type>
	bool PointInTriangle(const std::array<Type, 2> &a, const std::array<Type, 2> &b, const std::array<Type, 2> &c, const std::array<Type, 2> &p) {
		return PointInTriangle(a[0], a[1], b[0], b[1], c[0], c[1], p[0], p[1]);
	}

	bool PointInTriangle(const gsl_vector *a, const gsl_vector *b, const gsl_vector *c, const gsl_vector *p = nullptr);

	/**
	 * @brief Rotate vector `x` around the `axis` by `angle`.
	 *
	 * @param x 3 dimensional vector
	 * @param axis the rotation axis.
	 * @param angle in rad
	 * @return status
	 */
	template <typename Type>
	int RotateAroundAxis(Type x[], Axis axis, Type angle) {
		const Type sin_angle = sin(angle), cos_angle = cos(angle);
		switch (axis) {
		case X:
			angle = x[1] * cos_angle - x[2] * sin_angle;
			x[2] = x[1] * sin_angle + x[2] * cos_angle;
			x[1] = angle;
			return Status::SUCCESS;
		case Y:
			angle = x[2] * cos_angle - x[0] * sin_angle;
			x[0] = x[2] * sin_angle + x[0] * cos_angle;
			x[2] = angle;
			return Status::SUCCESS;
		case Z:
			angle = x[0] * cos_angle - x[1] * sin_angle;
			x[1] = x[0] * sin_angle + x[1] * cos_angle;
			x[0] = angle;
			return Status::SUCCESS;
		default:
			return GSL_EINVAL;
		}
	}

	/**
	 * @brief
	 *
	 * @param cartesian 4 or 8 dimensional vector
	 * @param spherical 4 or 8 dimensional vector
	 * @param dimension 4 or 8.
	 * @return status
	 */
	template <typename Type>
	int CartesianToSpherical(const Type cartesian[], Type spherical[], size_t dimension = 8) {
#ifndef GSL_RANGE_CHECK_OFF
		if (dimension != 4 && dimension != 8) {
			throw std::invalid_argument(fmt::format("Invalid CartesianToSpherical dimension = {}", dimension));
		}
#endif
		if (spherical[1] = Norm(cartesian + 1); spherical[1] == 0.)
			return GSL_EZERODIV;
		const Type r_1 = 1. / spherical[1];
		spherical[0] = cartesian[0];
		spherical[2] = acos(cartesian[3] * r_1);
		if (dimension == 4) {
			spherical[3] = atan2(cartesian[2], cartesian[1]);
			return Status::SUCCESS;
		}
		spherical[4] = cartesian[4];
		spherical[5] = Dot(cartesian + 1, cartesian + 5) * r_1;
		if (const Type r_xy = Norm(cartesian + 1, 2); r_xy == 0.) {
			spherical[3] = atan2(cartesian[6], cartesian[5]);
			spherical[6] = GSL_SIGN(cartesian[3]) * Norm(cartesian + 5, 2) * r_1;
			spherical[7] = 0;
		} else {
			spherical[3] = atan2(cartesian[2], cartesian[1]);
			spherical[6] = (-cartesian[7] + cartesian[3] * r_1 * spherical[5]) / r_xy;
			spherical[7] = (cartesian[6] * cartesian[1] - cartesian[5] * cartesian[2]) / Power2(r_xy);
		}
		return Status::SUCCESS;
	}

	/**
	 * @brief
	 *
	 * @param x 4 or 8 dimensional vector
	 * @param dimension 4 or 8
	 * @return status
	 */
	template <typename Type>
	int CartesianToSpherical(Type x[], size_t dimension = 8) {
		Type cartesian[dimension];
		std::copy(x, x + dimension, cartesian);
		return CartesianToSpherical(cartesian, x, dimension);
	}

	/**
	 * @brief
	 *
	 * @param spherical 4 or 8 dimensional vector
	 * @param cartesian 4 or 8 dimensional vector
	 * @param dimension 4 or 8.
	 * @return status
	 */
	template <typename Type>
	int SphericalToCartesian(const Type spherical[], Type cartesian[], size_t dimension = 8) {
#ifndef GSL_RANGE_CHECK_OFF
		if (dimension != 4 && dimension != 8) {
			throw std::invalid_argument(fmt::format("Invalid SphericalToCartesian dimension = {}", dimension));
		}
#endif
		const Type sin_theta = abs(sin(spherical[2])), cos_theta = GSL_SIGN(spherical[2]) * cos(spherical[2]), sin_phi = sin(spherical[3]), cos_phi = cos(spherical[3]);
		cartesian[0] = spherical[0];
		cartesian[1] = spherical[1] * sin_theta * cos_phi;
		cartesian[2] = spherical[1] * sin_theta * sin_phi;
		cartesian[3] = spherical[1] * cos_theta;
		if (dimension == 8) {
			cartesian[4] = spherical[4];
			cartesian[5] = spherical[5] * sin_theta * cos_phi + spherical[1] * (cos_theta * cos_phi * spherical[6] - sin_theta * sin_phi * spherical[7]);
			cartesian[6] = spherical[5] * sin_theta * sin_phi + spherical[1] * (cos_theta * sin_phi * spherical[6] + sin_theta * cos_phi * spherical[7]);
			cartesian[7] = spherical[5] * cos_theta - spherical[1] * sin_theta * spherical[6];
		}
		return Status::SUCCESS;
	}

	/**
	 * @brief
	 *
	 * @param x 4 or 8 dimensional vector
	 * @param dimension 4 or 8.
	 * @return status
	 */
	template <typename Type>
	int SphericalToCartesian(Type x[], size_t dimension = 8) {
		Type spherical[dimension];
		std::copy(x, x + dimension, spherical);
		return SphericalToCartesian(spherical, x, dimension);
	}

	template <typename Type>
	Type SphericalAngle(Type cos_theta_x, Type cos_theta_y, Type delta_theta_xy, Type delta_phi_xy) {
		const Type a = Power2(sin(0.5 * delta_theta_xy)) + cos_theta_x * cos_theta_y * Power2(sin(0.5 * PhiDifference(delta_phi_xy)));
		return 2. * atan2(SquareRoot(a), SquareRoot(1. - a));
	}

	/**
	 * @brief Return `1` if `x`, `y` have opposite signs, else `0`.
	 *
	 * @param x number
	 * @param y number
	 * @return result
	 */
	template <typename Type>
	int OppositeSign(Type x, Type y) {
		return (x > 0. && y < 0.) || (x < 0. && y > 0.);
	}

	/**
	 * @brief The modified spherical coordiante maps the polar angle from \f$\theta\in[0,\pi]\f$ to \f[
	 * \theta'\equiv\begin{cases}\theta & (\theta\leq\pi/2)\\
	 * \theta-\pi & (\theta>\pi/2)\end{cases}.
	 * \f]
	 * @param theta_0 theta in the last integration step
	 * @param y 8 dimensional vector
	 * @return status
	 */
	template <typename Type>
	int MapTheta(const Type theta_0, Type y[]) {
		if (OppositeSign(theta_0, y[2])) {
			y[2] = -y[2];
			y[3] += M_PI;
			y[6] = -y[6];
		} else if (y[2] <= -M_PI_2)
			y[2] += M_PI;
		else if (y[2] > M_PI_2)
			y[2] -= M_PI;
		return Status::SUCCESS;
	}

	template <typename Type>
	int MapTheta(const Type theta_0, double y[]) {
		if (OppositeSign(theta_0, static_cast<Type>(y[2]))) {
			y[2] = -y[2];
			y[3] += M_PI;
			y[6] = -y[6];
		} else if (y[2] <= -M_PI_2)
			y[2] += M_PI;
		else if (y[2] > M_PI_2)
			y[2] -= M_PI;
		return Status::SUCCESS;
	}

	/**
	 * @brief Return `phi` in \f$[0, 2\pi)\f$.
	 *
	 * @param phi \f$\phi\f$
	 * @return result
	 */
	template <typename Type>
	Type ModBy2Pi(Type phi) {
		return phi - floor(phi / M_2PI) * M_2PI;
	}

	/**
	 * @brief Similar to `ModBy2Pi`, but return `phi` in \f$[-\pi, \pi)\f$.
	 *
	 * @param phi \f$\phi\f$
	 * @return result
	 */
	template <typename Type>
	Type PhiDifference(Type phi) {
		return phi - floor(phi / M_2PI + 0.5) * M_2PI;
	}

	template <typename Type>
	int AMinusPlusB(Type a, Type b, Type &a_minus_b, Type &a_plus_b) {
		a_minus_b = a - b;
		a_plus_b = a + b;
		return Status::SUCCESS;
	}

	/**
	 * @brief Linear interpolation of points (`x0`, `y0`) and (`x1`, `y1`) at `x`. \f[y=\frac{y_0(x_1-x)+y_1(x-x_0)}{x_1-x_0}\f]
	 *
	 * @param x position to evaluate \f$y\f$
	 * @param x0 \f$x_0\f$
	 * @param x1 \f$x_1\f$
	 * @param y0 \f$y_0\f$
	 * @param y1 \f$y_1\f$
	 * @return result
	 */
	template <typename Type>
	Type LinearInterpolation(Type x, Type x0, Type x1, Type y0, Type y1) {
		if (x0 == x1)
			return 0.5 * (y0 + y1);
		return (y0 * (x1 - x) + y1 * (x - x0)) / (x1 - x0);
	}

	/**
	 * @brief Linear interpolation of vectors (`x0`, `y0`) and (`x1`, `y1`) at `x`, stored in `y`. \f[y=\frac{y_0(x_1-x)+y_1(x-x_0)}{x_1-x_0}\f]
	 *
	 * @param x position to evaluate \f$y\f$
	 * @param x0 \f$x_0\f$
	 * @param x1 \f$x_1\f$
	 * @param y0 \f$y_0\f$
	 * @param y1 \f$y_1\f$
	 * @param y \f$y\f$
	 * @param size size of the vectors
	 * @return status
	 */
	template <typename Type>
	int LinearInterpolation(Type x, Type x0, Type x1, const Type y0[], const Type y1[], Type y[], size_t size) { // FIXME
		memset(y, 0, sizeof(Type) * size);
		if (x0 == x1) {
			while (size-- > 0)
				y[size] = 0.5 * (y0[size] + y1[size]);
			return Status::SUCCESS;
		}
		const Type x01_1 = 1. / (x1 - x0);
		while (size-- > 0)
			y[size] = (x - x0) * x01_1 * y1[size] + (x1 - x) * x01_1 * y0[size];
		return Status::SUCCESS;
	}

	/**
	 * @brief Linear interpolation of two spherical positions `y0` and `y1` at `t`, stored in `y`. \f[y=\frac{\text{SphericalToCartesian}(y_0)(t_1-t)+\text{SphericalToCartesian}(y_1)(t-t_0)}{t_1-t_0}\f]
	 *
	 * @param t time to evaluate \f$y\f$
	 * @param t0 \f$t_0\f$
	 * @param t1 \f$t_1\f$
	 * @param y0 8 dimensional vector, spherical, \f$y_0\f$
	 * @param y1 8 dimensional vector, spherical, \f$y_1\f$
	 * @param y 8 dimensional vector, cartesian, \f$y\f$
	 * @return status
	 */
	template <typename Type>
	int InterpolateSphericalPositionToCartesian(Type t, Type t0, Type t1, const Type y0[], const Type y1[], Type y[]) {
		Type c0[8], c1[8];
		SphericalToCartesian(y0, c0);
		SphericalToCartesian(y1, c1);
		return LinearInterpolation(t, t0, t1, c0, c1, y, 8);
	}

	/**
	 * @brief Calculate the bolometric flux. The result is \f[F_\text{obs}=\frac{L_\text{src}}{(1+z)^2}\frac{\Omega_\text{src}}{\Omega_\text{obs}}.\f] The additional \f$(1+z)^{-1}\f$ comes from the expansion of the frequency that \f$(1+z)^{-1}=\frac{\nu_\text{obs}}{\nu_\text{src}}\f$.
	 *
	 * @param luminosity intrinsic luminosity of the source, \f$L_\text{src}\f$
	 * @param magnification magnification of the source, including the relativistic redshift and beaming, and gravitational lensing. \f$\frac{\Omega_\text{src}}{(1+z)\Omega_\text{obs}}\f$
	 * @param redshift relativistic redshift of the source, \f$1+z\f$
	 * @return result
	 */
	template <typename Type>
	Type Flux(Type luminosity, Type magnification, Type redshift) {
		return luminosity * magnification / redshift;
	}

	/**
	 * @brief Calculate the flux density. The result is \f[F_{\nu,\text{obs}}=\frac{L_{\nu,\text{src}}}{1+z}\frac{\Omega_\text{src}}{\Omega_\text{obs}}.\f]
	 *
	 * @param spectral_density intrinsic spectral density of the source, \f$L_{\nu,\text{src}}\f$
	 * @param magnification magnification of the source, including the relativistic redshift and beaming, and gravitational lensing. \f$\frac{\Omega_\text{src}}{(1+z)\Omega_\text{obs}}\f$
	 * @return result
	 */
	template <typename Type>
	Type FluxDensity(Type spectral_density, Type magnification) {
		return spectral_density * magnification;
	}

	template <typename Type>
	int PolishQuadraticRoot(Type a, Type b, Type roots[], int root_num) {
		int convinced_root_num = 0;
		for (int i = 0; i < root_num; ++i) {
			for (int j = 32; j > 0; --j) {
				Type f = roots[i] + a;
				f = fma(f, roots[i], b);
				Type df = fma(2.l, roots[i], a);
				const Type diff = f * df / (df * df - f);
				if (abs(roots[i]) * boost::math::tools::epsilon<Type>() < abs(diff))
					roots[i] -= diff;
				else {
					++convinced_root_num;
					break;
				}
			}
		}
		std::sort(roots, roots + convinced_root_num);
		return convinced_root_num;
	}

	template <typename Type>
	int PolySolveQuadratic(Type a, Type b, Type c, Type roots[]) {
		if (a == 0.) {
			if (b == 0.)
				return 0;
			roots[0] = -c / b;
			return 1;
		}
		if (b == 0.) {
			const Type square_of_root = -c / a;
			if (square_of_root < 0.)
				return 0;
			roots[1] = sqrt(square_of_root);
			roots[0] = -roots[1];
			return 2;
		}
		const Type delta = b * b - 4. * a * c;
		if (delta < 0.)
			return 0;
		else if (delta == 0.) {
			roots[0] = roots[1] = -0.5 * b / a;
			return 2;
		}
		const Type numerator = b > 0. ? -0.5 * (b + sqrt(delta)) : -0.5 * (b - sqrt(delta));
		if (a > 0.) {
			roots[0] = numerator / a;
			roots[1] = c / numerator;
		} else {
			roots[0] = c / numerator;
			roots[1] = numerator / a;
		}
		return 2;
	}

	template <typename Type>
	int PolishCubicRoot(Type a, Type b, Type c, Type roots[], int root_num) {
		int convinced_root_num = 0;
		for (int i = 0; i < root_num; ++i) {
			for (int j = 32; j > 0; --j) {
				Type f = roots[i] + a;
				f = fma(f, roots[i], b);
				f = fma(f, roots[i], c);
				Type df = fma(3.l, roots[i], 2. * a);
				df = fma(df, roots[i], b);
				Type d2f = fma(6.l, roots[i], 2. * a);
				const Type diff = f * df / (df * df - 0.5 * f * d2f);
				if (abs(roots[i]) * boost::math::tools::epsilon<Type>() < abs(diff))
					roots[i] -= diff;
				else {
					++convinced_root_num;
					break;
				}
			}
		}
		std::sort(roots, roots + convinced_root_num);
		return convinced_root_num;
	}

	template <typename Type>
	int PolySolveCubic(Type a, Type b, Type c, Type roots[]) {
		if (c == 0.) {
			roots[0] = 0.;
			int root_num = PolySolveQuadratic<Type>(1., a, b, roots + 1) + 1;
			return PolishCubicRoot(a, b, c, roots, root_num);
		}
		Type B = (a * a - 3. * b) / 9.;
		Type C = (2. * a * a * a - 9. * a * b + 27. * c) / 54.;
		Type Delta = C * C - B * B * B;
		if (Delta < 0.) {
			Type sqrt_B = sqrt(B);
			Type theta = acos(C / (B * sqrt_B)) / 3.;
			Type sqrt3_sin_theta = boost::math::constants::root_three<Type>() * sin(theta);
			Type cos_theta = cos(theta);
			roots[0] = -2. * sqrt_B * cos_theta - a / 3.;
			roots[1] = sqrt_B * (cos_theta - sqrt3_sin_theta) - a / 3.;
			roots[2] = sqrt_B * (cos_theta + sqrt3_sin_theta) - a / 3.;
			return PolishCubicRoot(a, b, c, roots, 3);
		}
		Type X = (C >= 0. ? -1. : 1.) * cbrt(abs(C) + sqrt(Delta));
		Type Y = X == 0. ? 0. : B / X;
		roots[0] = X + Y - a / 3.;
		if (X == Y || Delta == 0.) {
			roots[1] = roots[2] = -X - a / 3.;
			return PolishCubicRoot(a, b, c, roots, 3);
		}
		return PolishCubicRoot(a, b, c, roots, 1);
	}

	template <typename Type>
	int PolishQuarticRoot(Type a, Type b, Type c, Type d, Type roots[], int root_num) {
		int convinced_root_num = 0;
		for (int i = 0; i < root_num; ++i) {
			for (int j = 32; j > 0; --j) {
				Type f = roots[i] + a;
				f = fma(f, roots[i], b);
				f = fma(f, roots[i], c);
				f = fma(f, roots[i], d);
				Type df = fma(4., roots[i], 3. * a);
				df = fma(df, roots[i], 2. * b);
				df = fma(df, roots[i], c);
				Type d2f = fma(12., roots[i], 6. * a);
				d2f = fma(d2f, roots[i], 2. * b);
				const Type diff = f * df / (df * df - 0.5 * f * d2f);
				if (abs(roots[i]) * boost::math::tools::epsilon<Type>() < abs(diff))
					roots[i] -= diff;
				else {
					++convinced_root_num;
					break;
				}
			}
		}
		std::sort(roots, roots + convinced_root_num);
		return convinced_root_num;
	}

	template <typename Type>
	int PolySolveQuarticWithZero(Type a, Type b, Type c, Type offset, Type roots[]) {
		if (int root_num = PolySolveCubic(a, b, c, roots); root_num == 1) {
			if (roots[0] < 0.) {
				roots[0] += offset;
				roots[1] = offset;
			} else {
				roots[1] = roots[0] + offset;
				roots[0] = offset;
			}
			return 2;
		}
		// root_num == 3
		roots[3] = offset;
		if (offset != 0.)
			for (int i = 0; i < 3; ++i)
				roots[i] += offset;
		for (int i = 3; i > 0 && roots[i] < roots[i - 1]; --i)
			std::swap(roots[i], roots[i - 1]);
		return 4;
	}

	/**
	 * @brief Solve for real roots of the quartic equation \f$x^4+ax^3+bx^2+cx=0\f$. The roots are returned in `x0`, `x1`, `x2`, and `x3` and satisfied \f$x_0\leq x_1\leq x_2\leq x_3\f$. The function is based on `quartic_roots` from `boost/math/tools/quartic_roots.hpp`.
	 *
	 * @param a \f$a\f$
	 * @param b \f$b\f$
	 * @param c \f$c\f$
	 * @param d \f$d\f$
	 * @param roots
	 *
	 * @return number of real roots
	 */
	template <typename Type>
	int PolySolveQuartic(Type a, Type b, Type c, Type d, Type roots[]) {
		if (d == 0.)
			return PolishQuarticRoot(a, b, c, d, roots, PolySolveQuarticWithZero(a, b, c, 0., roots));
		// Now solve x^4 + ax^3 + bx^2 + cx + d = 0.
		const Type a_4 = 0.25 * a;
		const Type a2_16 = Power2(a_4);
		// Let x = y - a/4:
		// Mathematica: Expand[(y - a/4)^4 + a*(y - a/4)^3 + b*(y - a/4)^2 + c*(y - a/4) + d]
		// We now solve the depressed quartic y^4 + py^2 + qy + r = 0.
		const Type p = b - 6. * a2_16;
		const Type q = c - 2. * b * a_4 + 2. * a * a2_16;
		const Type r = d - c * a_4 + b * a2_16 - 3. * a2_16 * a2_16;
		if (r == 0.)
			return PolishQuarticRoot(a, b, c, d, roots, PolySolveQuarticWithZero(0., p, q, -a_4, roots));
		// Biquadratic case:
		if (q == 0.) {
			if (int root_num = PolySolveQuadratic(1., p, r, roots); root_num == 0)
				return 0;
			if (roots[0] >= 0.) { // roots[1] >= roots[0]
				Type root_of_root_0 = sqrt(roots[0]);
				Type root_of_root_1 = sqrt(roots[1]);
				roots[0] = -root_of_root_1 - a_4;
				roots[1] = -root_of_root_0 - a_4;
				roots[2] = root_of_root_0 - a_4;
				roots[3] = root_of_root_1 - a_4;
				return PolishQuarticRoot(a, b, c, d, roots, 4);
			}
			if (roots[1] >= 0.) {
				Type root_of_root_1 = sqrt(roots[1]);
				roots[0] = -root_of_root_1 - a_4;
				roots[1] = root_of_root_1 - a_4;
				return PolishQuarticRoot(a, b, c, d, roots, 2);
			}
			return 0;
		}

		// Now split the depressed quartic into two quadratics:
		// y^4 + py^2 + qy + r = (y^2 + sy + u)(y^2 - sy + v) = y^4 + (v+u-s^2)y^2 + s(v - u)y + uv
		// So p = v+u-s^2, q = s(v - u), r = uv.
		// Then (v+u)^2 - (v-u)^2 = 4uv = 4r = (p+s^2)^2 - q^2/s^2.
		// Multiply through by s^2 to get s^2(p+s^2)^2 - q^2 - 4rs^2 = 0, which is a cubic in s^2.
		// Then we let z = s^2, to get
		// z^3 + 2pz^2 + (p^2 - 4r)z - q^2 = 0.
		int z_root_num = PolySolveCubic(2. * p, p * p - 4. * r, -q * q, roots);
		// z = s^2, so s = sqrt(z).
		// Hence we require a root > 0, and for the sake of sanity we should take the largest one:
		Type largest_root = z_root_num == 1 ? roots[0] : roots[2];
		if (int status = PolishCubicRoot(2. * p, p * p - 4. * r, -q * q, &largest_root, 1); status == 0)
			largest_root = z_root_num == 1 ? roots[0] : roots[2];
		if (largest_root <= 0.) // No real roots:
			return 0;
		const Type s = sqrt(largest_root);
		// s is nonzero, because we took care of the biquadratic case.
		const Type v = 0.5 * (p + largest_root + q / s);
		const Type u = v - q / s;
		// We have q != 0., so u != v
		if (u > v) {
			// Now solve y^2 - sy + v = 0:
			if (PolySolveQuadratic(1., -s, v, roots) == 0)
				return 0;
			std::swap(roots[0], roots[1]); // roots[1] > 0 are more convinced, put it to the front
		} else {
			// Now solve y^2 + sy + u = 0:
			if (PolySolveQuadratic(1., s, u, roots) == 0) // roots[0] < 0 are more convinced
				return 0;
		}
		roots[0] -= a_4;
		roots[1] -= a_4;
		if (int status = PolishQuarticRoot(a, b, c, d, roots, 2); status == 1) { // roots[1] is not convinced, solve the cubic to get another root:
			int rest_root_num = PolySolveCubic(a + roots[0], b + (a + roots[0]) * roots[0], -d / roots[0], roots + 1);
			if (rest_root_num == 3 && u < v)
				std::swap(roots[1], roots[3]); // we want the largest root in this case
			PolishQuarticRoot(a, b, c, d, roots + 1, 1);
		}
		const Type prod_r2_r3 = d / (roots[0] * roots[1]);
		const Type sum_r2_r3 = prod_r2_r3 * (roots[0] + roots[1]) / (roots[0] * roots[1]);
		if (PolySolveQuadratic(1., sum_r2_r3, prod_r2_r3, roots + 2) == 0) {
			if (roots[0] > roots[1])
				std::swap(roots[0], roots[1]);
			return 2;
		}
		return PolishQuarticRoot(a, b, c, d, roots, 4);
	}

	template <typename Type>
	Type CarlsonRC(Type x, Type y) {
		if (y < 0.)
			return sqrt(x / (x - y)) * boost::math::ellint_rc(x - y, -y);
		return boost::math::ellint_rc(x, y);
	}

	template <typename Type>
	Type CarlsonRJ(Type x, Type y, Type z, Type p) {
		if (p <= 0.) {
			if ((x >= y && z >= x) || (x <= y && z <= x))
				std::swap(x, y);
			else if ((z >= y && x >= z) || (z <= y && x <= z))
				std::swap(y, z);
			const Type y_1 = 1. / y, y_p_1 = 1. / (y - p), gamma = y + (z - y) * (y - x) * y_p_1; // make sure gamma > 0.
			return ((gamma - y) * boost::math::ellint_rj(x, y, z, gamma) - 3. * (boost::math::ellint_rf(x, y, z) - CarlsonRC(x * z * y_1, p * gamma * y_1))) * y_p_1;
		}
		return boost::math::ellint_rj(x, y, z, p);
	}

	/**
	 * @brief \f[\int_y^x(a_5+b_5t)^{p_5/2}\prod_{i=1}^4(a_i+b_it)^{-1/2}dt\f].
	 *
	 * @return result
	 */
	template <typename Type>
	Type EllipticIntegral_GSL(int p5, Type y, Type x, Type a5, Type b5, Type a1, Type b1, Type a2, Type b2, Type a3, Type b3, Type a4 = 1., Type b4 = 0.) {
		if (x == y)
			return 0.;
		if (p5 != 0 && p5 != -2 && p5 != -4)
			return GSL_NAN;
		const Type d12 = a1 * b2 - a2 * b1, d13 = a1 * b3 - a3 * b1, d14 = a1 * b4 - a4 * b1;
		const Type d23 = a2 * b3 - a3 * b2, d24 = a2 * b4 - a4 * b2, d34 = a3 * b4 - a4 * b3;
		const Type X1 = sqrt(a1 + b1 * x), X2 = sqrt(a2 + b2 * x), X3 = sqrt(a3 + b3 * x), X4 = sqrt(a4 + b4 * x), X52 = a5 + b5 * x;
		const Type Y1 = sqrt(a1 + b1 * y), Y2 = sqrt(a2 + b2 * y), Y3 = sqrt(a3 + b3 * y), Y4 = sqrt(a4 + b4 * y), Y52 = a5 + b5 * y;
		const Type U2_12 = Power2((X1 * X2 * Y3 * Y4 + Y1 * Y2 * X3 * X4) / (x - y));
		const Type U2_13 = U2_12 - d14 * d23;
		const Type U2_14 = U2_12 - d13 * d24;
		const Type I1 = 2. * gsl_sf_ellint_RF(U2_12, U2_13, U2_14, GSL_PREC_DOUBLE);
		if (p5 == 0)
			return I1;
		const Type b52 = Power2(b5);
		const Type d15 = a1 * b5 - a5 * b1, d15_1 = 1. / d15, d25 = a2 * b5 - a5 * b2, d35 = a3 * b5 - a5 * b3, d45 = a4 * b5 - a5 * b4;
		const Type W2 = U2_12 - d13 * d14 * d25 * d15_1;
		const Type Q2 = X52 * Y52 * W2 / Power2(X1 * Y1);
		const Type P2 = Q2 + d25 * d35 * d45 * d15_1;
		const Type RC_P2_Q2 = X1 * Y1 == 0. ? 0. : CarlsonRC(P2, Q2);
		const Type I3 = 2. * (d12 * d13 * d14 * d15_1 / 3. * CarlsonRJ(U2_12, U2_13, U2_14, W2) + RC_P2_Q2);
		if (p5 == -2)
			return (b5 * I3 - b1 * I1) * d15_1;
		const Type I2 = 2. * (d12 * d13 * gsl_sf_ellint_RD(U2_12, U2_13, U2_14, GSL_PREC_DOUBLE) / 3. + X1 * Y1 / (X4 * Y4 * sqrt(U2_14)));
		return -0.5 * d15_1 * (b1 / d15 + b2 / d25 + b3 / d35 + b4 / d45) * b5 * I3 + b52 * d24 * d34 / (2. * d15 * d25 * d35 * d45) * I2 + Power2(b1 * d15_1) * (1. - d12 * d13 * b52 / (2. * b1 * b1 * d25 * d35)) * I1 - b52 / (d15 * d25 * d35) * (X1 * X2 * X3 / (X4 * X52) - Y1 * Y2 * Y3 / (Y4 * Y52));
	}
	template <typename Type>
	Type EllipticIntegral(int p5, Type y, Type x, Type a5, Type b5, Type a1, Type b1, Type a2, Type b2, Type a3, Type b3, Type a4 = 1., Type b4 = 0.) {
		if (x == y)
			return 0.;
		if (p5 != 0 && p5 != -2 && p5 != -4)
			return GSL_NAN;
		const Type d12 = a1 * b2 - a2 * b1, d13 = a1 * b3 - a3 * b1, d14 = a1 * b4 - a4 * b1;
		const Type d23 = a2 * b3 - a3 * b2, d24 = a2 * b4 - a4 * b2, d34 = a3 * b4 - a4 * b3;
		const Type X1 = sqrt(a1 + b1 * x), X2 = sqrt(a2 + b2 * x), X3 = sqrt(a3 + b3 * x), X4 = sqrt(a4 + b4 * x), X52 = a5 + b5 * x;
		const Type Y1 = sqrt(a1 + b1 * y), Y2 = sqrt(a2 + b2 * y), Y3 = sqrt(a3 + b3 * y), Y4 = sqrt(a4 + b4 * y), Y52 = a5 + b5 * y;
		const Type U2_12 = Power2((X1 * X2 * Y3 * Y4 + Y1 * Y2 * X3 * X4) / (x - y));
		const Type U2_13 = U2_12 - d14 * d23;
		const Type U2_14 = U2_12 - d13 * d24;
		const Type I1 = 2. * boost::math::ellint_rf(U2_12, U2_13, U2_14);
		if (p5 == 0)
			return I1;
		const Type b52 = b5 * b5;
		const Type d15 = a1 * b5 - a5 * b1, d15_1 = 1. / d15, d25 = a2 * b5 - a5 * b2, d35 = a3 * b5 - a5 * b3, d45 = a4 * b5 - a5 * b4;
		const Type W2 = U2_12 - d13 * d14 * d25 * d15_1;
		const Type Q2 = X52 * Y52 * W2 / Power2(X1 * Y1);
		const Type P2 = Q2 + d25 * d35 * d45 * d15_1;
		const Type RC_P2_Q2 = X1 * Y1 == 0. ? 0. : CarlsonRC(P2, Q2);
		const Type I3 = 2. * (d12 * d13 * d14 * d15_1 / 3. * CarlsonRJ(U2_12, U2_13, U2_14, W2) + RC_P2_Q2);
		if (p5 == -2)
			return (b5 * I3 - b1 * I1) * d15_1;
		const Type I2 = 2. * (d12 * d13 * boost::math::ellint_rd(U2_12, U2_13, U2_14) / 3. + X1 * Y1 / (X4 * Y4 * sqrt(U2_14)));
		return -0.5 * d15_1 * (b1 / d15 + b2 / d25 + b3 / d35 + b4 / d45) * b5 * I3 + b52 * d24 * d34 / (2. * d15 * d25 * d35 * d45) * I2 + Power2(b1 * d15_1) * (1. - d12 * d13 * b52 / (2. * b1 * b1 * d25 * d35)) * I1 - b52 / (d15 * d25 * d35) * (X1 * X2 * X3 / (X4 * X52) - Y1 * Y2 * Y3 / (Y4 * Y52));
	}

	/**
	 * @brief \f[\int_y^x(a_5+b_5t)^{p_5/2}(f+gt+ht^2)^{-1/2}\prod_{i=1,4}(a_i+b_it)^{-1/2}dt\f].
	 *
	 * @return result
	 */
	template <typename Type>
	Type EllipticIntegral2Complex_GSL(int p5, Type y, Type x, Type a5, Type b5, Type f, Type g, Type h, Type a1, Type b1, Type a4 = 1., Type b4 = 0.) {
		if (x == y)
			return 0.;
		if (p5 != 0 && p5 != -2 && p5 != -4)
			return GSL_NAN;
		const Type b12 = Power2(b1), b52 = Power2(b5);
		const Type X1 = sqrt(a1 + b1 * x), X4 = sqrt(a4 + b4 * x);
		const Type Y1 = sqrt(a1 + b1 * y), Y4 = sqrt(a4 + b4 * y);
		const Type xi = sqrt(f + (g + h * x) * x), eta = sqrt(f + (g + h * y) * y);
		const Type M2 = Power2(X1 * Y4 + X4 * Y1) * (Power2((xi + eta) / (x - y)) - h);
		const Type c2_11 = 2 * (f * b12 - g * a1 * b1 + h * a1 * a1), c2_44 = 2 * (f * b4 * b4 - g * a4 * b4 + h * a4 * a4);
		const Type c2_14 = 2. * f * b1 * b4 - g * (a1 * b4 + a4 * b1) + 2. * h * a1 * a4, c2_15 = 2. * f * b1 * b5 - g * (a1 * b5 + a5 * b1) + 2. * h * a1 * a5;
		const Type c11 = sqrt(c2_11), c44 = sqrt(c2_44), c11_c44 = c11 * c44;
		const Type L2m = std::max(0., M2 + c2_14 - c11_c44), L2p = std::max(0., M2 + c2_14 + c11_c44);
		const Type I1 = 4. * gsl_sf_ellint_RF(M2, L2m, L2p, GSL_PREC_DOUBLE);
		if (p5 == 0)
			return I1;
		const Type X52 = a5 + b5 * x, Y52 = a5 + b5 * y;
		const Type c2_55 = 2 * (f * b52 - g * a5 * b5 + h * a5 * a5), c55 = sqrt(c2_55);
		const Type d14 = a1 * b4 - a4 * b1, d15 = a1 * b5 - a5 * b1, d15_1 = 1. / d15, d45 = a4 * b5 - a5 * b4;
		const Type W2p = M2 + d14 * (c2_15 + c11 * c55) * d15_1;
		const Type U = (X1 * X4 * eta + Y1 * Y4 * xi) / (x - y), U2 = Power2(U);
		const Type W2 = U2 - 0.5 * c2_11 * d45 * d15_1;
		const Type Q2 = X52 * Y52 * W2 / Power2(X1 * Y1);
		const Type P2 = Q2 + 0.5 * c2_55 * d45 * d15_1;
		const Type RC_P2_Q2 = X1 * Y1 == 0. ? 0. : CarlsonRC(P2, Q2);
		const Type I3 = 2. * (c11 / (3. * c55) * (4. * (W2p - M2) * CarlsonRJ(M2, L2m, L2p, W2p) - 1.5 * I1 + 3. * CarlsonRC(U2, W2)) + RC_P2_Q2);
		if (p5 == -2)
			return (b5 * I3 - b1 * I1) * d15_1;
		const Type I2 = 2. * (c11 / (3. * c44) * (4. * (c2_14 + c11_c44) * gsl_sf_ellint_RD(M2, L2m, L2p, GSL_PREC_DOUBLE) - 1.5 * I1 + 3. / U) + X1 * Y1 / (X4 * Y4 * U));
		return -0.5 * d15_1 * ((b1 * b5) / d15 + 2. * b5 * (g * b5 - 2. * h * a5) / c2_55 + (b4 * b5) / d45) * I3 + b52 * 0.5 * c2_44 / (d15 * d45 * c2_55) * I2 + Power2(b1 * d15_1) * (1. - 0.5 * c2_11 * b52 / (b12 * c2_55)) * I1 - b52 / (0.5 * d15 * c2_55) * (X1 * xi / (X4 * X52) - Y1 * eta / (Y4 * Y52));
	}
	template <typename Type>
	Type EllipticIntegral2Complex(int p5, Type y, Type x, Type a5, Type b5, Type f, Type g, Type h, Type a1, Type b1, Type a4 = 1., Type b4 = 0.) {
		if (x == y)
			return 0.;
		if (p5 != 0 && p5 != -2 && p5 != -4)
			return GSL_NAN;
		const Type b12 = b1 * b1, b52 = b5 * b5;
		const Type X1 = sqrt(a1 + b1 * x), X4 = sqrt(a4 + b4 * x);
		const Type Y1 = sqrt(a1 + b1 * y), Y4 = sqrt(a4 + b4 * y);
		const Type xi = sqrt(f + (g + h * x) * x), eta = sqrt(f + (g + h * y) * y);
		const Type M2 = Power2(X1 * Y4 + X4 * Y1) * (Power2((xi + eta) / (x - y)) - h);
		const Type c2_11 = 2 * (f * b12 - g * a1 * b1 + h * a1 * a1), c2_44 = 2 * (f * b4 * b4 - g * a4 * b4 + h * a4 * a4);
		const Type c2_14 = 2. * f * b1 * b4 - g * (a1 * b4 + a4 * b1) + 2. * h * a1 * a4, c2_15 = 2. * f * b1 * b5 - g * (a1 * b5 + a5 * b1) + 2. * h * a1 * a5;
		const Type c11 = sqrt(c2_11), c44 = sqrt(c2_44), c11_c44 = c11 * c44;
		const Type L2m = std::max(0., M2 + c2_14 - c11_c44), L2p = std::max(0., M2 + c2_14 + c11_c44);
		const Type I1 = 4. * boost::math::ellint_rf(M2, L2m, L2p);
		if (p5 == 0)
			return I1;
		const Type X52 = a5 + b5 * x, Y52 = a5 + b5 * y;
		const Type c2_55 = 2 * (f * b52 - g * a5 * b5 + h * a5 * a5), c55 = sqrt(c2_55);
		const Type d14 = a1 * b4 - a4 * b1, d15 = a1 * b5 - a5 * b1, d15_1 = 1. / d15, d45 = a4 * b5 - a5 * b4;
		const Type W2p = M2 + d14 * (c2_15 + c11 * c55) * d15_1;
		const Type U = (X1 * X4 * eta + Y1 * Y4 * xi) / (x - y), U2 = U * U;
		const Type W2 = U2 - 0.5 * c2_11 * d45 * d15_1;
		const Type Q2 = X52 * Y52 * W2 / Power2(X1 * Y1);
		const Type P2 = Q2 + 0.5 * c2_55 * d45 * d15_1;
		const Type RC_P2_Q2 = X1 * Y1 == 0. ? 0. : CarlsonRC(P2, Q2);
		const Type I3 = 2. * (c11 / (3. * c55) * (4. * (W2p - M2) * CarlsonRJ(M2, L2m, L2p, W2p) - 1.5 * I1 + 3. * CarlsonRC(U2, W2)) + RC_P2_Q2);
		if (p5 == -2)
			return (b5 * I3 - b1 * I1) * d15_1;
		const Type I2 = 2. * (c11 / (3. * c44) * (4. * (c2_14 + c11_c44) * boost::math::ellint_rd(M2, L2m, L2p) - 1.5 * I1 + 3. / U) + X1 * Y1 / (X4 * Y4 * U));
		return -0.5 * d15_1 * ((b1 * b5) / d15 + 2. * b5 * (g * b5 - 2. * h * a5) / c2_55 + (b4 * b5) / d45) * I3 + b52 * 0.5 * c2_44 / (d15 * d45 * c2_55) * I2 + Power2(b1 * d15_1) * (1. - 0.5 * c2_11 * b52 / (b12 * c2_55)) * I1 - b52 / (0.5 * d15 * c2_55) * (X1 * xi / (X4 * X52) - Y1 * eta / (Y4 * Y52));
	}

	/**
	 * @brief \f[\int_y^x(a_5+b_5t)^{p_5/2}\prod_{i=1}^2(f_i+g_it+h_it^2)^{-1/2}dt\f].
	 *
	 * @return result
	 */
	template <typename Type>
	Type EllipticIntegral4Complex_GSL(int p5, Type y, Type x, Type a5, Type b5, Type f1, Type g1, Type h1, Type f2, Type g2, Type h2) {
		if (x == y)
			return 0.;
		if (p5 != 0 && p5 != -2 && p5 != -4)
			return GSL_NAN;
		const Type x_y_1 = 1. / (x - y);
		const Type xi12 = f1 + (g1 + h1 * x) * x, eta12 = f1 + (g1 + h1 * y) * y;
		const Type xi22 = f2 + (g2 + h2 * x) * x, eta22 = f2 + (g2 + h2 * y) * y;
		const Type xi1 = sqrt(xi12), eta1 = sqrt(eta12);
		const Type xi2 = sqrt(xi22), eta2 = sqrt(eta22);
		const Type xi1p = (g1 + 2. * h1 * x) / (2. * xi1), eta_1p = (g1 + 2. * h1 * y) / (2. * eta1);
		const Type B = xi1p * xi2 - eta_1p * eta2;
		const Type theta1 = xi12 + eta12 - h1 * Power2(x - y);
		const Type theta2 = xi22 + eta22 - h2 * Power2(x - y);
		const Type zeta1 = sqrt(2. * xi1 * eta1 + theta1), zeta2 = sqrt(2. * xi2 * eta2 + theta2);
		const Type U = (xi1 * eta2 + xi2 * eta1) * x_y_1, U2 = Power2(U);
		const Type M = zeta1 * zeta2 * x_y_1;
		const Type M2 = Power2(M);
		const Type delta11_2 = 4. * f1 * h1 - Power2(g1), delta12_2 = 2. * (f1 * h2 + f2 * h1) - g1 * g2, delta22_2 = 4. * f2 * h2 - Power2(g2);
		const Type Delta = sqrt(Power2(delta12_2) - delta11_2 * delta22_2);
		const Type Delta_m = delta12_2 - Delta, Delta_p = delta12_2 + Delta;
		const Type L2m = M2 + Delta_m, L2p = M2 + Delta_p;
		const Type RF = gsl_sf_ellint_RF(M2, L2m, L2p, GSL_PREC_DOUBLE);
		if (p5 == 0)
			return 4. * RF;
		const Type G = 2. * Delta * Delta_p * gsl_sf_ellint_RD(M2, L2m, L2p, GSL_PREC_DOUBLE) / 3. + Delta / (2. * U) + (delta12_2 * theta1 - delta11_2 * theta2) / (4. * xi1 * eta1 * U);
		const Type Sigma = G - Delta_p * RF + B;
		const Type alpha15 = 2. * f1 * b5 - g1 * a5, beta15 = g1 * b5 - 2. * h1 * a5;
		const Type alpha25 = 2. * f2 * b5 - g2 * a5, beta25 = g2 * b5 - 2. * h2 * a5;
		const Type gamma1 = 0.5 * (alpha15 * b5 - beta15 * a5), gamma2 = 0.5 * (alpha25 * b5 - beta25 * a5);
		const Type gamma1_1 = 1. / gamma1, gamma2_1 = 1. / gamma2;
		const Type Lambda = delta11_2 * gamma2 * gamma1_1;
		const Type Omega2 = M2 + Lambda;
		const Type psi = 0.5 * (alpha15 * beta25 - alpha25 * beta15);
		const Type xi5 = a5 + b5 * x, eta5 = a5 + b5 * y;
		const Type X = 0.5 * x_y_1 * (xi5 * (alpha15 + beta15 * y) * eta2 / eta1 + eta5 * (alpha15 + beta15 * x) * xi2 / xi1);
		const Type S = 0.5 * (M2 + delta12_2) - U2, S2 = Power2(S);
		const Type mu = gamma1 * xi5 * eta5 / (xi1 * eta1);
		const Type T = mu * S + 2. * gamma1 * gamma2, T2 = Power2(T);
		const Type V2 = Power2(mu) * (S2 + Lambda * U2);
		const Type a = S * Omega2 / U + 2. * Lambda * U, a2 = Power2(a);
		const Type b2 = (S2 / U2 + Lambda) * Power2(Omega2);
		const Type H = delta11_2 * psi * Power2(gamma1_1) * (CarlsonRJ(M2, L2m, L2p, Omega2) / 3. + 0.5 * CarlsonRC(a2, b2)) - X * CarlsonRC(T2, V2);
		if (p5 == -2)
			return -2. * (b5 * H + beta15 * RF * gamma1_1);
		return b5 * (beta15 * gamma1_1 + beta25 * gamma2_1) * H + Power2(beta15 * gamma1_1) * RF + Power2(b5) * (Sigma - b5 * (xi1 * xi2 / xi5 - eta1 * eta2 / eta5)) * gamma1_1 * gamma2_1;
	}
	template <typename Type>
	Type EllipticIntegral4Complex(int p5, Type y, Type x, Type a5, Type b5, Type f1, Type g1, Type h1, Type f2, Type g2, Type h2) {
		if (x == y)
			return 0.;
		if (p5 != 0 && p5 != -2 && p5 != -4)
			return GSL_NAN;
		const Type x_y_1 = 1. / (x - y);
		const Type xi12 = f1 + (g1 + h1 * x) * x, eta12 = f1 + (g1 + h1 * y) * y;
		const Type xi22 = f2 + (g2 + h2 * x) * x, eta22 = f2 + (g2 + h2 * y) * y;
		const Type xi1 = sqrt(xi12), eta1 = sqrt(eta12);
		const Type xi2 = sqrt(xi22), eta2 = sqrt(eta22);
		const Type xi1p = (g1 + 2. * h1 * x) / (2. * xi1), eta_1p = (g1 + 2. * h1 * y) / (2. * eta1);
		const Type B = xi1p * xi2 - eta_1p * eta2;
		const Type theta1 = xi12 + eta12 - h1 * Power2(x - y);
		const Type theta2 = xi22 + eta22 - h2 * Power2(x - y);
		const Type zeta1 = sqrt(2. * xi1 * eta1 + theta1), zeta2 = sqrt(2. * xi2 * eta2 + theta2);
		const Type U = (xi1 * eta2 + xi2 * eta1) * x_y_1, U2 = U * U;
		const Type M = zeta1 * zeta2 * x_y_1;
		const Type M2 = M * M;
		const Type delta11_2 = 4. * f1 * h1 - g1 * g1, delta12_2 = 2. * (f1 * h2 + f2 * h1) - g1 * g2, delta22_2 = 4. * f2 * h2 - g2 * g2;
		const Type Delta = sqrt(delta12_2 * delta12_2 - delta11_2 * delta22_2);
		const Type Delta_m = delta12_2 - Delta, Delta_p = delta12_2 + Delta;
		const Type L2m = M2 + Delta_m, L2p = M2 + Delta_p;
		const Type RF = boost::math::ellint_rf(M2, L2m, L2p);
		if (p5 == 0)
			return 4. * RF;
		const Type G = 2. * Delta * Delta_p * boost::math::ellint_rd(M2, L2m, L2p) / 3. + Delta / (2. * U) + (delta12_2 * theta1 - delta11_2 * theta2) / (4. * xi1 * eta1 * U);
		const Type Sigma = G - Delta_p * RF + B;
		const Type alpha15 = 2. * f1 * b5 - g1 * a5, beta15 = g1 * b5 - 2. * h1 * a5;
		const Type alpha25 = 2. * f2 * b5 - g2 * a5, beta25 = g2 * b5 - 2. * h2 * a5;
		const Type gamma1 = 0.5 * (alpha15 * b5 - beta15 * a5), gamma2 = 0.5 * (alpha25 * b5 - beta25 * a5);
		const Type gamma1_1 = 1. / gamma1, gamma2_1 = 1. / gamma2;
		const Type Lambda = delta11_2 * gamma2 * gamma1_1;
		const Type Omega2 = M2 + Lambda;
		const Type psi = 0.5 * (alpha15 * beta25 - alpha25 * beta15);
		const Type xi5 = a5 + b5 * x, eta5 = a5 + b5 * y;
		const Type X = 0.5 * x_y_1 * (xi5 * (alpha15 + beta15 * y) * eta2 / eta1 + eta5 * (alpha15 + beta15 * x) * xi2 / xi1);
		const Type S = 0.5 * (M2 + delta12_2) - U2, S2 = S * S;
		const Type mu = gamma1 * xi5 * eta5 / (xi1 * eta1);
		const Type T = mu * S + 2. * gamma1 * gamma2, T2 = T * T;
		const Type V2 = mu * mu * (S2 + Lambda * U2);
		const Type a = S * Omega2 / U + 2. * Lambda * U, a2 = a * a;
		const Type b2 = (S2 / U2 + Lambda) * Omega2 * Omega2;
		const Type H = delta11_2 * psi * gamma1_1 * gamma1_1 * (CarlsonRJ(M2, L2m, L2p, Omega2) / 3. + 0.5 * CarlsonRC(a2, b2)) - X * CarlsonRC(T2, V2);
		if (p5 == -2)
			return -2. * (b5 * H + beta15 * RF * gamma1_1);
		return b5 * (beta15 * gamma1_1 + beta25 * gamma2_1) * H + Power2(beta15 * gamma1_1) * RF + b5 * b5 * (Sigma - b5 * (xi1 * xi2 / xi5 - eta1 * eta2 / eta5)) * gamma1_1 * gamma2_1;
	}

	/**
	 * @brief A wrapper of the gsl_odeiv2_evolve
	 *
	 */
	class Integrator {
	  private:
		///
		gsl_odeiv2_control *control_;
		///
		gsl_odeiv2_evolve *evolve_;
		///
		gsl_odeiv2_step *step_;
		///
		gsl_odeiv2_system system_;

	  public:
		/**
		 * @brief Construct a new Integrator object.
		 *
		 * @param function The function calculates \f[\frac{\mathrm dy_i(t)}{\mathrm dt}=f_i\left[t,y_1(t),\dots,y_n(t)\right].\f]
		 * @param jacobian The jacobian of the function \f[J_{ij}=\frac{\partial f_i\left[t,y(t)\right]}{\partial y_j}.\f]
		 * @param params The parameters passed to the function, like the PN parameter, or the spin of the black hole.
		 * @param type Type of the algorithms. Explicit embedded Runge-Kutta Prince-Dormand (8, 9) method is set by default.
		 */
		Integrator(int (*function)(double, const double *, double *, void *), int (*jacobian)(double, const double *, double *, double *, void *), void *params = nullptr, const gsl_odeiv2_step_type *type = gsl_odeiv2_step_rk8pd) : control_(gsl_odeiv2_control_y_new(absolute_accuracy, relative_accuracy)), evolve_(gsl_odeiv2_evolve_alloc(8)), step_(gsl_odeiv2_step_alloc(type, 8)) {
			system_ = gsl_odeiv2_system{function, jacobian, 8UL, params};
		}

		/// Destructor
		~Integrator() {
			gsl_odeiv2_control_free(control_);
			gsl_odeiv2_evolve_free(evolve_);
			gsl_odeiv2_step_free(step_);
		}

		/**
		 * @brief `gsl_odeiv2_evolve_apply`.
		 *
		 * @param t time.
		 * @param t1 maximum time not to be exceeded by the time step.
		 * @param h step size.
		 * @param y values of the integrated system.
		 * @return status
		 */
		int Apply(double *t, long double t1, double *h, double *y) {
			int status = 0;
			long double theta_0 = y[2];
			if (*h > 0)
				while (status <= 0 && *t < t1)
					status = gsl_odeiv2_evolve_apply(evolve_, control_, step_, &system_, t, t1, h, y);
			else
				while (status <= 0 && *t > t1)
					status = gsl_odeiv2_evolve_apply(evolve_, control_, step_, &system_, t, t1, h, y);
			MapTheta(theta_0, y);
			y[3] = ModBy2Pi(y[3]);
			return status;
		}

		/**
		 * @brief `gsl_odeiv2_evolve_apply`.
		 *
		 * @param t time.
		 * @param t1 maximum time not to be exceeded by the time step.
		 * @param h step size.
		 * @param y values of the integrated system.
		 * @return status
		 */
		int ApplyStep(double *t, long double t1, double *h, double *y) {
			long double theta_0 = y[2];
			int status = gsl_odeiv2_evolve_apply(evolve_, control_, step_, &system_, t, t1, h, y);
			MapTheta(theta_0, y);
			y[3] = ModBy2Pi(y[3]);
			return status;
		}

		/**
		 * @brief `gsl_odeiv2_evolve_apply_fixed_step`.
		 *
		 * @param t time.
		 * @param h step size.
		 * @param y values of the integrated system.
		 * @return status
		 */
		int ApplyFixedStep(double *t, const long double h, double *y) {
			long double theta_0 = y[2];
			int status = gsl_odeiv2_evolve_apply_fixed_step(evolve_, control_, step_, &system_, t, h, y);
			MapTheta(theta_0, y);
			y[3] = ModBy2Pi(y[3]);
			return status;
		}

		/**
		 * @brief Resets the evolution function and the stepping function.
		 *
		 * @return status
		 */
		int Reset() {
			if (int status = gsl_odeiv2_evolve_reset(evolve_); status != Status::SUCCESS)
				return status;
			if (int status = gsl_odeiv2_step_reset(step_); status != Status::SUCCESS)
				return status;
			return Status::SUCCESS;
		}

		/**
		 * @brief
		 *
		 * @param y
		 * @return status
		 */
		int CheckCoordinate(long double *y);
	};
} // namespace SBody

#endif
